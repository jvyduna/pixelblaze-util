{
  "name": "Unit tests: pass on 3.17",
  "id": "R2rtmFZtNvyMyrwed",
  "sources": {
    "main": "/*\n  Unit tests for consistency across language versions\n  \n  Assumes we're testing PB v3\n  Assumes a 3D map is defined. \n  \n  The tests are organized into suites. Uncomment the suites you want to run at\n  the very bottom of the code. (It's unclear to me if hoisting works the same \n  way as in JS)\n  \n  No coverage: Sensor board globals, UI controls, watcher, websockets, `delta`\n  No coverage, but these are called: hsv(), hsv24(), rgb(), all mapper transforms\n  Weak coverage: time(), random(), clock and IO functions\n*/\n\n\n/********************************************************************************\n * Testting framework: assert(), assertNear(), and assertTrig()\n ********************************************************************************/\n\n\nfunction abort() {}\n// Uncomment the following line to have the IDE highlight the line of the first failing test.\n// var abort = null\n\n\n// HW v2: 128 global variables, 512 stack variables, 64 arrays, and 2048 array elements\n// HW v3:  256 global variables, 256 stack variables, and 10,240 arrays/elements\nvar results = array(2049) // Should exceed v2\nresults.mutate(() => -1)  // Init array to a value that means \"untested\"\n\n// Useful constants\n// var epsilon = 1 >> 16 // Causes weird behaviors in watcher\nvar epsilon = 1 >> 15\nvar oneMinusEpsilon = ((0x00FF >> 8) + 0xFF) >> 8 // 0x0.FFFF,  0.99998474121 (.999985 in watcher)\nvar largestInt = 0x7FFF\nvar largestNum = 0x7FFF + oneMinusEpsilon\nvar smallestInt = 0x8000\nvar smallestDec = 0x8000 + (1>>7)\nvar trigTolerance = 0.007 // sin(PI) is the current limiting factor\n\nvar testId = 0\n// This is the main workhorse of the testing \"framework\". Asserts equality, \n// and stores the result sequentially. Call this by appending `|| abort()`\n// to allow the optional IDE highlighting off the first failing test. In\n// this mode, the exported failCount/passCount will not be accurate.\nfunction assert(actual, expected) {\n  var result = (expected == actual)\n  results[testId] = result\n  testId++\n  return result\n}\n\nvar defaultTolerance = 1 >> 12\nfunction assertNear(actual, expected, tolerance) { \n  tolerance = tolerance || defaultTolerance\n  return assert(abs(actual - expected) < tolerance, true)\n}\n\nfunction assertTrig(actual, expected) { \n  return assertNear(actual, expected, trigTolerance) \n}\n// These watchers are useful for use while defining new tests\nexport var w1 = -1, w2 = -1, w3 = -1\n\n\n\n/********************************************************************************\n * Test suites\n ********************************************************************************/\n\n/*\n  From the docs:\n  Declare global or function-local variables using var or globals implicitly.\n  The pixelCount variable is available as a global even during initialization. This is the number of LED pixels that have been configured in settings.\n  Variables can be created/assigned implicitly with the = operator. e.g.: foo=wave(time(0.1)) or explicitly using the var keyword. e.g.: var foo=1.\n  Implicit variables are global.\n  Explicitly declared variables will either be global or local depending on where they are declared. Local variables declared using var inside a function are visible inside that function. Local variables can shadow global variables with the same name.\n  Global variables can also be exported with the export keyword. These will be visible in the Var Watcher and can be used with the getVars and setVars websocket API.\n*/\nvar globalVar = -1\nimplicitGlobal = -2\nfunction scopeSuite() {\n  assert(globalVar, 0) || abort()\n  var globalVar = 1 // Symbol is now a distinct local\n  assert(globalVar, 1) || abort()\n  \n  implicitGlobalInner = 3\n\n  //assert(implicitGlobal, -2) || abort() // Uncomment - it SHOULD fail.\n  scopeSuiteExported()\n  \n  // Kinda random here - just asserting that this special global was defined\n  assert(pixelCount > 0, true) || abort()\n}\nassert(globalVar, -1) || abort() // Verifies it wasn't modified in scopeSuite()\nassert(implicitGlobalInner, 0) || abort() // Declared but not set since scopeSuite() not called yet\n\nexport function scopeSuiteExported() {\n  assert(globalVar, -1) || abort()\n  assert(implicitGlobal, -2) || abort() // Since the function is exported, it works\n  assert(implicitGlobalInner, 3) || abort()\n}\n\n\n/*\n  From the docs:\n  Use if and else to have some code run conditionally.\n  Use while and for for making loops and use break and continue statements to escape a loop or loop early.\n  Define functions using the function keyword or short lambda-style form.\n    function myFunction(arg1){return arg1 * 2}\n    myFunction=(arg1)=> arg1 * 2\n  Functions can be stored in variables, passed as arguments, and returned from other functions.\n*/\nfunction controlFlowSuite() {\n  var tmp = -1\n  tmp = true ? 1 : 0\n  assert(tmp, 1) || abort()\n  tmp = false ? 1 : 0\n  assert(tmp, 0) || abort()\n  if (true) { tmp = 2 } else {tmp = -2}\n  assert(tmp, 2) || abort()\n  if (false) { tmp = -3 } else {tmp = 3}\n  assert(tmp, 3) || abort()\n  \n  tmp = 0\n  for (i = 0; i < 4; i++) {\n    tmp += i\n  }\n  assert(i, 4) || abort()\n  assert(tmp, 6) || abort()\n  \n  i = 4; tmp = 0\n  while (i > 0) {\n    tmp += -i\n    i--\n  }\n  assert(i, 0) || abort()\n  assert(tmp, -10) || abort()\n  \n  tmp = 0\n  for (i = 1; i <= 5; i++) {\n    if (i == 4) break\n    if (i == 2) continue\n    tmp += i\n  }\n  assert(i, 4) || abort()\n  assert(tmp, 4) || abort()\n  \n  var fnShortLambda = (foo) => foo * foo\n  assert(fnShortLambda(2), 4) || abort()\n  \n  var fnLambdaNoReturn = (foo) => { foo * foo }\n  assert(fnLambdaNoReturn(2), null) || abort()\n  \n  var fnLambda = (foo) => { return foo + foo }\n  assert(fnLambda(3), 6) || abort()\n  \n  assert(fnLambda(fnShortLambda(4)), 32) || abort()\n  \n  function returnsFn (arg) {\n    arg += 1\n    return (arg) => sqrt(arg)\n  }\n  var returnedFn = returnsFn\n  assert(returnedFn(9)(4), 2) || abort()\n}\n\n\n/*\n  From the docs:\n  All of the usual math operators work. Most work on 16.16 fixed-point math. =, +, -, !, *, \n  /, %, >>, <<, |, &, ~, ^, >, <, >=, <=, ==, !=, ||, &&, ?.\n*/\nfunction operationsSuite() {\n  // Literal representations\n  assert(0x000F, 15) || abort()\n  assert(0b1000000000000000, -32768) || abort()\n  assert(5.91909E3, 5919.09) || abort()\n  \n  // Fixed point precision behaviors\n  assert(.0001, .000092) || abort()\n  assert(1 >> 15, .000031) || abort()\n  // assert(1 >> 16, 0x7fff) || abort() // TODO This is a werid one - makes wacher explode\n  assert(1 >> 17, 0) || abort()\n  // assert(0x7FFF >> 16, 0.4999847412109375) || abort() // TODO 0x7FFF >> 16 seems hard to represent in dec\n  // assert(((0x7fff >> 15) + 1) >> 1, 0.9999847412109375)  // TODO\n\n  // =\n  var testAssignment = 1\n  assert(testAssignment, 1) || abort()\n  \n  // +\n  assert(2 + 1, 3) || abort()\n  \n  // + overflow\n  assert(0x7FFF + 1, -32768) || abort()\n  assert(0xFFFF + 1, 0) || abort()\n  \n  // -\n  assert(3 - 1, 2) || abort()\n  \n  // - overflow\n  assert(-32768 - 1, 32767) || abort()\n  assert(-32768 - 32768, 0) || abort()\n  \n  // - precision\n  assert(0x8000 + (1 >> 7), -32767.9921875) || abort()\n  assert(0x8000 + (1 >> 15), -32767.99996948242) || abort()\n  // assert(0x8000 + (1 >> 16), -32767.99998474121) || abort() // More epsilon quirks\n  \n  // Equality, Zero is falsey\n  assert(1, 1) || abort()\n  assert(false, 0) || abort()\n  \n  // Negation\n  assert(!false, true) || abort()\n  assert(!9e9, false) || abort()\n  assert(!!0, 0) || abort()\n  assert(!!-1, 1) || abort()\n  \n  // Multiplication\n  assert(0 * 0, 0) || abort()\n  assert(0 * 1, 0) || abort()\n  assert(-1 * -2, 2) || abort()\n  assert(-2 * .5, -1) || abort()\n  assert((1 << 15)  * (1 >> 15), -1) || abort()\n  assert(0x7FFF * (1 >> 15), .99997) || abort()\n  assert(0x7FFF * (1 >> 16), 0x7FFF >> 16) || abort()\n  \n  // Division\n  assert(0 / 1, 0) || abort()\n  assert(1 / 0, 0) || abort()\n  assert(0 / 0, 0) || abort()\n  assert(-1 / -2, .5) || abort()\n  assert(-2 / .5, -4) || abort()\n  assert((1 << 15)  / (1 << 14), -2) || abort()\n  assert((1 >> 16)  / (1 >> 15), .5) || abort()\n  assert(((0x7fff >> 15) + 1) >> 1 / 0.000005, 1.99997) || abort() // Beyond Jeff's pay grade\n  \n  // Remainder\n  assert(0 % 0, 0) || abort()\n  assert(0 % 5, 0) || abort()\n  assert(5 % 0, 0) || abort()\n  assert(5 % 1, 0) || abort()\n  assert(5 % 2, 1) || abort()\n  assert(5 % -3, 2) || abort()\n  assert(-5 % 3, -2) || abort()\n  assert(-5 % 0, 0) || abort()\n  \n  // Modulus\n  assert(mod(0, 0), 0) || abort()\n  assert(mod(0, 5), 0) || abort()\n  assert(mod(5, 0), 0) || abort()\n  assert(mod(5, 1), 0) || abort() // TODO failing on 3.16, pass 3.17\n  assert(mod(5, 1.5), .5) || abort()\n  assert(mod(5, 2), 1) || abort()\n  assert(mod(5, 5), 0) || abort() // TODO failing on 3.16, pass 3.17\n  assert(mod(5, -3), -1) || abort()\n  assert(mod(-5, 3), 1) || abort()\n  assert(mod(-5, -3), -2) || abort()\n  assert(mod(-5, 0), 0) || abort()\n  \n  // Shifts\n  assert(1 >> 1, .5) || abort()\n  assert(.5 << 2, 2) || abort()\n  assert(1 >> 17, 0) || abort()\n  assert(1 << 17, 0) || abort()\n  assert(1 << 16, 0) || abort()\n  assert(1 << 15, -32768) || abort()\n  assert(0xFFFF >> 1, -.5) || abort() // Right shift preserves sign bit\n  assert((1 >> 16) << 31, 32768) || abort()\n  \n  // Or\n  assert(true | false, true) || abort()\n  assert(0 | 0, false) || abort()\n  assert(0x00F0 | 15, 255) || abort()\n  assert(0b0101010101010101 | 0b1010101010101010, -1) || abort()\n  assert(-1 | .5, -.5) || abort()\n  assert(6 | 3, 7) || abort()\n  \n  // Bitwise and\n  assert(true & false, false) || abort()\n  assert(1 & 1, true) || abort()\n  assert(0x00F0 & 15, 0) || abort()\n  assert(0b0101010101010101 & 0b1010101010101010, 0) || abort()\n  assert(-1 & .5, 0) || abort()\n  assert(6 & 3, 2) || abort()\n  \n  // Bitwise not\n  assert(~0, -1) || abort()\n  assert(~-1,0) || abort()\n  assert(~1, -2) || abort()\n  assert(~0xFFFF, 0) || abort()\n  assert(~0b0101010101010101, 0b1010101010101010) || abort()\n  assert(~(0b0101010101010101 >> 8), -86) // Bitwise not truncates decimals\n  \n  // XOR\n  assert(0 ^ 0, 0) || abort()\n  assert(0 ^ 1, 1) || abort()\n  assert(1 ^ 1, 0) || abort()\n  assert(6 ^ 3, 5) || abort()\n  assert(1.5 ^ 2.25, 3.75) || abort()\n  assert(0xF2A3 ^ -0xE975, -7128) || abort()\n  \n  // Greater than\n  assert(1 > 0, true) || abort()\n  assert(0 > 0, false) || abort()\n  assert(1 > 1.0, false) || abort()\n  assert(1 > -1, true) || abort()\n  assert(1 > 2.2, false) || abort()\n  assert(-2 > -20000, true) || abort()\n  assert(0x8000 > 0x7FFF, false) || abort()\n  \n  // Less than\n  assert(1 < 0, false) || abort()\n  assert(0 < 0, false) || abort()\n  assert(1 < 1.0, false) || abort()\n  assert(1 < -1, false) || abort()\n  assert(1 < 2.2, true) || abort()\n  assert(-2 < -20000, false) || abort()\n  assert(0x8000 < 0x7FFF, true) || abort()\n  \n  // Greater than or equal to\n  assert(1 >= 0, true) || abort()\n  assert(0 >= 0, true) || abort()\n  assert(1 >= 1.0, true) || abort()\n  assert(1 >= 8, false) || abort()\n  assert(0 >= 1, false) || abort()\n  assert(-1 <= 1.0, true) || abort()\n  \n  // Less than or equal to\n  assert(1 <= 0, false) || abort()\n  assert(0 <= 0, true) || abort()\n  assert(1 <= 1.0, true) || abort()\n  assert(1 <= 8, true) || abort()\n  assert(0 <= 1, true) || abort()\n  assert(-1 <= 1.0, true) || abort()\n  \n  // Not equal to\n  assert(-1 != 1, true) || abort()\n  assert(1 != 1, false) || abort()\n  assert(1 != 0, true) || abort()\n  assert(0 != 0, false) || abort()\n  \n  // Logical or; Carries value\n  assert(2 || 1, 2) || abort()\n  assert(0 || 1, 1) || abort()\n  assert(false || 1, 1) || abort()\n  var tmpAssignment = 0 || 1\n  assert(tmpAssignment, 1) || abort()\n  \n  // Logical and\n  assert(true && true, true) || abort()\n  assert(true && false, false) || abort()\n  assert(.2 && 0, false) || abort()\n  assert(1 && .2, .2) || abort()\n  \n  // Ternary\n  assert(true ? 2 : 4, 2) || abort()\n  assert(false ? 2 : 4, 4) || abort()\n  \n  // Order of operations\n  assert(false ? 2 : true ? 1 : 3, 1) || abort()\n  assert(true ? true ? 1 : 3 : 2, 1) || abort()\n  var incr = 0\n  var ooo = true && 0 || incr++ + 9 % 8 * 7 & 60 | 42, oo2\n  assert(ooo, 46) || abort()\n}\n\n\n/* \n  From the docs:\n  Trig and other math functions. abs, floor, ceil, min, max, clamp, sin, cos, tan, \n  asin, acos, atan, atan2, sqrt, exp, log, log2, pow, random\n*/\nfunction mathSuite() {\n  assert(abs(0), 0) || abort()\n  assert(abs(0x7FFF), 32767) || abort()\n  assert(abs(0xFFFF), 1) || abort()\n  assert(abs(0x8001), 32767) || abort()  // abs(-32767) is 32767\n  assert(abs(0x8000), -32768) || abort() // Somewhat interesting that abs(-32768) is -32768 because 32768 is not represetable (it's the sign bit)\n  assert(abs(0x8001), 32767) || abort()\n  assert(abs(-epsilon), epsilon) || abort()\n  assert(abs(-oneMinusEpsilon), oneMinusEpsilon) || abort()\n  assert(abs(-(1>>8)), (1>>8)) || abort()\n  // assert(abs(-.6), .6) || abort() // Interesting .599976 != .600006, maybe 2s compliment \n  assert(abs(-.5), .5) || abort()\n  \n  assert(floor(-1.1), -2) || abort()\n  assert(floor(-1), -1) || abort()\n  assert(floor(-.9), -1) || abort()\n  assert(floor(0), 0) || abort()\n  assert(floor(.1), 0) || abort()\n  assert(floor(.9999), 0) || abort()\n  assert(floor(1), 1) || abort()\n  assert(floor(0xFFFF), 0xFFFF) || abort()\n  assert(floor(0x8000 + oneMinusEpsilon ), 0x8000) || abort()\n  \n  assert(ceil(-1.1), -1) || abort()\n  assert(ceil(-1), -1) || abort()\n  assert(ceil(-.9), 0) || abort()\n  assert(ceil(0), 0) || abort()\n  assert(ceil(epsilon), 1) || abort()\n  assert(ceil(oneMinusEpsilon), 1) || abort()\n  assert(ceil(1), 1) || abort()\n  assert(ceil(0xFFFF), 0xFFFF) || abort()\n  assert(ceil(0x8000 + oneMinusEpsilon ), -32767) || abort()\n  assert(ceil(0x8000 - oneMinusEpsilon ), -32768) || abort()\n  \n  assert(min(1, 9), 1) || abort()\n  assert(min(9, 1), 1) || abort()\n  assert(min(1, 1), 1) || abort()\n  assert(min(-20.99, 1), -20.99) || abort()\n  assert(min(largestNum, 0), 0) || abort()\n  assert(min(largestNum, smallestDec), smallestDec) || abort()\n  \n  assert(max(1, 9), 9) || abort()\n  assert(max(9, 1), 9) || abort()\n  assert(max(1, 1), 1) || abort()\n  assert(max(-20.99, 1), 1) || abort()\n  assert(max(largestNum, 0), largestNum) || abort()\n  assert(max(largestNum, smallestDec), largestNum) || abort()\n  \n  assert(clamp(0, 0, 1), 0) || abort()\n  assert(clamp(.5, 0, 1), .5) || abort()\n  assert(clamp(oneMinusEpsilon, 0, 1), oneMinusEpsilon) || abort()\n  assert(clamp(epsilon, 0, 1), epsilon) || abort()\n  assert(clamp(1, 0, 1), 1) || abort()\n  assert(clamp(-1, 0, 1), 0) || abort()\n  assert(clamp(2, 0, 1), 1) || abort()\n  assert(clamp(1, -2, -1), -1) || abort()\n  assert(clamp(smallestDec, -2, -1), -2) || abort()\n  assert(clamp(largestNum, -2, -1), -1) || abort()\n  assert(clamp(-1.2, -2, -1), -1.2) || abort()\n  \n  // sin, cos, tan\n  assert(sin(0), 0) || abort()\n  // Precision issues\n  // assert(sin(PI / 4), sqrt(2) / 2) || abort()\n  // assert(sin(PI / 2), 1) || abort()\n  // assert(sin(PI), 0) || abort()\n  // assert(sin(3 * PI * 2), 0) || abort()\n  // assert(sin(PI2), 0) || abort()\n  \n  // Precision with a tolerance\n  assertTrig(sin(PI / 4), sqrt(2) / 2) || abort()\n  assertTrig(sin(PI / 2), 1) || abort()\n  assertTrig(sin(PI3_4), sqrt(2) / 2) || abort()\n  assertTrig(sin(PI), 0) || abort()\n  assertTrig(sin(3 * PI * 2), 0) || abort()\n  assertTrig(sin(PI2), 0) || abort()\n  \n  assert(cos(0), sin(PI / 2)) || abort()\n  assert(cos(PI / 4), sin(PI * 3 / 4)) || abort()\n  assert(cos(PI / 2), sin(PI)) || abort()\n  assert(cos(PI3_4), sin(PI * 5 / 4)) || abort()\n  assert(cos(PI), sin(3 * PI / 2)) || abort()\n  assert(cos(3 * PI * 2), sin(PI / 2)) || abort()\n  assert(cos(PI2), sin(PI/2)) || abort()\n  \n  assert(tan(0), 0) || abort()\n  assertTrig(tan(PI / 6), sqrt(3) / 3) || abort()\n  assertTrig(tan(PI / 4), 1) || abort()\n  assertTrig(tan(PI / 3), sqrt(3)) || abort()\n  assertTrig(tan(PI), 0) || abort()\n  assertTrig(tan(PI2 / 3), -sqrt(3)) || abort()\n  assertTrig(tan(-PI / 6), -sqrt(3) / 3) || abort()\n\n  // asin - can be off by almost 5% sometimes\n  for (i = -.99; i < 1; i += .2) assertNear(sin(asin(i)), i, .009) || abort()\n  // acos\n  for (i = -.999; i < 1; i += .2) assertTrig(cos(acos(i)), i) || abort()\n  // atan\n  for (i = -PI/2+.1; i < PI/2; i+= .2) assertNear(atan(tan(i)), i, 1) || abort()\n  assertTrig(atan(-32766.9999), -PI/2) || abort()\n  assertTrig(atan(0), 0) || abort()\n  assertTrig(atan(32766.9999), PI/2) || abort()\n  assertTrig(atan(largestNum), 0) || abort()  // Kind of weird? Asserting to detect changes later\n  \n  assert(atan2(0, 0), 0) || abort()\n  assertTrig(atan2(0, 1), 0) || abort()\n  assert(atan2(1, 1), PI/4) || abort()\n  assert(atan2(1, 0), PI/2) || abort()\n  assertTrig(atan2(1, -1), 3*PI/4) || abort()\n  assertTrig(atan2(0, -1), PI) || abort()\n  assertTrig(atan2(-1, -1), -3*PI/4) || abort()\n  assert(atan2(-1, 0), -PI/2) || abort()\n  assert(atan2(-1, 1), -PI/4) || abort()\n  \n  assert(sqrt(0), 0) || abort()\n  assert(sqrt(1), 1) || abort()\n  assert(sqrt(.25), .5) || abort()\n  assertNear(sqrt(1/9), 1/3) || abort()\n  assert(sqrt(1 << 14), 1 << 7) || abort()\n  assert(sqrt(-9), -3) || abort()\n  assertNear(sqrt(largestNum), 181.01, .01) || abort()\n  assertNear(sqrt(smallestDec), -181.01, .01) || abort()\n  \n  assert(exp(0), 1) || abort()\n  assertNear(exp(1), E) || abort()\n  assertNear(exp(-1), 1/E) || abort()\n  assert(exp(largestNum), largestNum) || abort()\n  assertNear(exp(10), 22025.795, .001) || abort()\n  \n  assertNear(log(E), 1) || abort()\n  assertNear(log(1), 0) || abort()\n  assert(log(0), smallestInt) || abort()\n  assert(log(-1), smallestInt) || abort()\n  assert(log(smallestInt), smallestInt) || abort()\n  assertNear(log(pow(E, 5)), 5) || abort()\n  assertNear(log(exp(5)), 5) || abort()\n  \n  assert(log2(2), 1) || abort()\n  assert(log2(1), 0) || abort()\n  assert(log2(0), smallestInt) || abort()\n  assert(log2(-1), smallestInt) || abort()\n  assert(log2(smallestInt), smallestInt) || abort()\n  assert(log2(2*2*2), 3) || abort()\n  assert(log2(1 << 14), 14) || abort()\n  assert(log2(1 >> 6), -6) || abort()\n\n  assert(pow(0, 0), 1) || abort()\n  assert(pow(0, 1), 0) || abort()\n  assert(pow(1, 0), 1) || abort()\n  assert(pow(2, 4), 16) || abort()\n  assert(pow(smallestInt, 0), 1) || abort()\n  assert(pow(-3, 3), -27) || abort()\n  assert(pow(3, -3), 1/27) || abort()\n  assert(pow(largestNum, largestNum), largestNum) || abort()\n  assert(pow(0.01, 2), 0.0001) || abort()\n  assert(pow(1>>3, 1<<2), 1>>12) || abort()\n  \n  // Truly verifying a RNG is a bigger task than can be performed within PB's available memory\n  assert(random(-1) != 0, true) || abort() // random(a negative) is 32 bit random binary vector. So this could fail 1-in-4M times.\n  assert(random(0), 0) || abort()\n  for (i = 1; i <= largestNum/4; i *= 4) { // 1, 4, 16, 64, 256, 1024, 4096\n    var rand = random(i)\n    assert(rand > 0, true) || abort()\n    assert(rand < i, true) || abort()\n  }\n  \n  assert(frac(0), 0) || abort()\n  assert(frac(-1E4), 0) || abort()\n  assert(frac(0.99), .99) || abort()\n  assert(frac(-87.8274), -.8274) || abort()\n  \n  assert(trunc(0), 0) || abort()\n  assert(trunc(largestNum), largestInt) || abort()\n  assert(trunc(-1E4), -1E4) || abort()\n  assert(trunc(0.99), 0) || abort()\n  assert(trunc(-87.8274), -87) || abort()\n  \n  assert(round(0), 0) || abort()\n  assert(round(47.499999), 47) || abort()\n  assert(round(7 >> 1), 4) || abort()\n  assert(round(-1.5), -1) || abort()\n  assert(round(-1.5001), -2) || abort()\n  assert(round(-2047.5), -2047) || abort()\n  assert(round(largestNum), smallestInt) || abort()\n  assert(round(smallestDec), smallestInt) || abort()  \n\n  assert(hypot(0, 0), 0) || abort()  \n  assert(hypot(0, -10), 10) || abort()\n  assert(hypot(-3, 4), 5) || abort()\n  assert(hypot(21, 28), 35) || abort()\n  assert(hypot(44, 117), 125) || abort()\n  assertNear(hypot(57, 176), -176.9491) || abort() // Overflow\n  assert(hypot(PISQ, SQRT1_2), sqrt(PISQ*PISQ + SQRT1_2*SQRT1_2)) || abort()\n  \n  assert(hypot3(0, 0, 0), 0) || abort()  \n  assert(hypot3(3, 0, -4), 5) || abort()\n  assert(hypot3(-5, 3, 0), hypot(3, 5)) || abort()\n  assert(hypot3(1, 2, 3), sqrt(14)) || abort()\n  assert(hypot3(-.002, 1.9, .45), sqrt(.002*.002 + 1.9*1.9 + .45*.45)) || abort()\n  \n  // Constants\n  // E, PI, PI2 (PI * 2), PI3_4 (PI * 3 / 4), PISQ (PI * PI), LN2, LN10, LOG2E, LOG10E, SQRT1_2, SQRT2\n  assertNear(E, 2.72, .01*E) || abort()\n  assertNear(PI, 3.14, .01*PI) || abort()\n  assertNear(PI2, 6.28, .01*PI2) || abort()\n  assertNear(PI3_4, 2.36, .01*PI3_4) || abort()\n  assertNear(PISQ, 9.87, .01*PISQ) || abort()\n  assertNear(LN2, .69, .01*LN2) || abort()\n  assertNear(LN10, 2.3, .01*LN10) || abort()\n  assertNear(LOG2E, 1.44, .01*LOG2E) || abort()\n  assertNear(LOG10E, .43, .01*LOG10E) || abort()\n  assertNear(SQRT1_2, .71, .01*SQRT1_2) || abort()\n  assertNear(SQRT2, 1.41, .01*SQRT2) || abort()\n}\n\n// See Array docs in the IDE. Not copied here.\n// A little sloppy: tests depend on results from prior tests. \nfunction arraySuite() {\n  var arr5 = array(5)\n  var arr42 = array(42.9)\n\n  assert(arrayLength(arr5), 5) || abort()\n  assert(arr42.length, 42) || abort()\n  \n  arrayForEach(arr5, function (value, index, a) {\n    a[index] = pow(-index, index)\n  })\n  assert(arr5[3], -27) || abort()\n  \n  arr42.forEach((v,i,a) => a[i] = 1/i )\n  assert(arr42[2], .5) || abort()\n  \n  var sum = arrayReduce(arr42, (acc, v) => acc + v, 0)\n  assertNear(sum, 4.3026) || abort()\n  sum = arraySum(arr42)\n  assertNear(sum, 4.3026) || abort()\n  \n  sum = arr5.reduce((acc, value, index, array) => {\n    return array[index] == value ? acc + value : 0\n  }, 0)\n  assert(sum, 233) || abort()\n  sum = arr5.sum()\n  assert(sum, 233) || abort()\n  \n  target = .99/4 // arr42[4] == 1/4\n  closestIndex = arrayReduce(arr42, (acc, v, i, a) => abs(target - v) < abs(target - a[acc]) ? i : acc, 0)\n  assert(closestIndex, 4) || abort()\n  \n  arr5.mutate((v, i) => i * v)\n  assert(arr5[4], 1024) || abort()\n  \n  arrayMutate(arr42, (v, i, a) => v + i + a[max(0, i=1)])\n  assert(arr42[4], 7.25) || abort()\n  \n  arr5.mutate((v, i) => i)\n  arr42.mutate((v, i) => i * pow(-1, i))\n  arrayMapTo(arr42, arr5, (v, i, a) => v + i)\n  assert(arr5[4], 8) || abort()\n  arr5.mutate((v, i) => i)\n  arr5.mapTo(arr42, (v, i, a) => v + i)\n  assert(arr42[3], 6) || abort()\n  assert(arr42[5], -5) || abort()\n  \n  arr5.mutate((v, i) => i * pow(-1, i))  // [0, -1, 2, -3, 4]\n  arraySort(arr5)\n  assert(arr5[0], -3) || abort()\n  assert(arr5[2], 0) || abort()\n  assert(arr5[4], 4) || abort()\n  \n  // Back to original - sort by absolute value\n  arraySortBy(arr5, (v1, v2) => abs(v1) < abs(v2) ? -1 : 1)\n  assert(arr5[0], 0) || abort()\n  assert(arr5[1], -1) || abort()\n  assert(arr5[4], 4) || abort()\n  \n  arr5.sort()\n  assert(arr5[0], -3) || abort()\n  \n  arr5.sortBy((v1, v2) => abs(v1) < abs(v2) ? -1 : 1)\n  assert(arr5[0], 0) || abort()\n}\n\n\n/*\n  Fromthe docs:\n  Waveform Functions\n  time(interval) -A sawtooth waveform between 0.0 and 1.0 that loops about every 65.536*interval seconds. e.g. use .015 for an approximately 1 second.\n    Patterns using this can be synchronized across the network using either Firestorm, or when connecting to a Pixelblaze in AP mode.\n  wave(v) - Converts a sawtooth waveform v between 0.0 and 1.0 to a sinusoidal waveform between 0.0 to 1.0. Same as (1+sin(v*PI2))/2 but faster. v \"wraps\" between 0.0 and 1.0.\n  square(v, duty) - Converts a sawtooth waveform v to a square wave using the provided duty cycle where duty is a number between 0.0 and 1.0. v \"wraps\" between 0.0 and 1.0.\n  triangle(v) - Converts a sawtooth waveform v between 0.0 and 1.0 to a triangle waveform between 0.0 to 1.0. v \"wraps\" between 0.0 and 1.0.\n*/\nfunction waveSuite() {\n  // time() verificiation is very basic\n  assert(time(0), 0) || abort()\n  assert(time(1) <= 1, true) || abort()\n  assert(time(2) >= 0, true) || abort()\n  \n  assert(wave(0), .5) || abort()\n  assert(wave(.25), 1) || abort()\n  assertNear(wave(.5), .5, .01) || abort()\n  assert(wave(.75), 0) || abort()\n  assert(wave(1), .5) || abort()\n  assert(wave(100), .5) || abort()\n  assert(wave(-.25), 0) || abort()\n  assert(wave(-.5), wave(.5)) || abort()\n  \n  assert(triangle(0), 0) || abort()\n  assert(triangle(.25), .5) || abort()\n  assert(triangle(.5), 1) || abort()\n  assert(triangle(.75), .5) || abort()\n  assert(triangle(1), 0) || abort()\n  assert(triangle(100), 0) || abort()\n  assert(triangle(-.25), .5) || abort()\n  \n  assert(square(0, .2), 1) || abort()\n  assert(square(.2-epsilon, .2), 1) || abort()\n  assert(square(.2, .2), 0) || abort()\n  assert(square(1-epsilon, .2), 0) || abort()\n  assert(square(1, .2), 1) || abort()\n  assert(square(-epsilon, .2), 0) || abort()\n  assert(square(-.8, .2), 0) || abort()\n  assert(square(-.8-epsilon, .2), 0) || abort()\n  assert(square(largestInt, .2), 1) || abort()\n  assert(square(smallestInt, .2), 1) || abort()\n  assert(square(0, 1 - epsilon), 1) || abort()\n  assert(square(1 - epsilon, 1 - 2 * epsilon), 0) || abort()\n  assert(square(1, 1 - epsilon), 1) || abort()\n  assert(square(0, -.2), 0) || abort()\n  assert(square(.1, -.2), 0) || abort()\n  assert(square(.21, -.2), 0) || abort()\n  assert(square(.9, -.2), 0) || abort()\n  assert(square(-.25, 1.5), 1) || abort()\n  assert(square(0, 1.5), 1) || abort()\n  assert(square(.7, 1.5), 1) || abort()\n  assert(square(1.4, 1.5), 1) || abort()\n  assert(square(2, 1.5), 1) || abort()\n}\n\n// See Array docs in the IDE. Not copied here.\nfunction ioSuite() {\n  pinMode(33, ANALOG)\n  assert(analogRead(33) >= 0, true) || abort()\n  assert(analogRead(33) <= 1, true) || abort()\n  \n  tPins = array(5)\n  tPins[0] = T0; tPins[1] = T2; tPins[2] = T4\n  tPins[3] = T6; tPins[4] = T7\n  tPins.forEach((pin) => {\n    pinMode(pin, INPUT)\n    assert(touchRead(pin) >= 0, true) || abort()\n    assert(touchRead(pin) <= 1, true) || abort()\n  })\n  \n  GPIOPins = array(12)\n  GPIOPins[0] = 0; GPIOPins[1] = 25; GPIOPins[2] = 26; GPIOPins[3] = 2;\n  GPIOPins[4] = 4; GPIOPins[5] = 14; GPIOPins[6] = 19; GPIOPins[7] = 21;\n  GPIOPins[8] = 22; GPIOPins[9] = 33; GPIOPins[10] = 27; GPIOPins[11] = 13;\n  \n  GPIOPins.forEach((pin) => {\n    pinMode(pin, INPUT)\n    assert(digitalRead(pin) == 0 || digitalRead(pin) == 1, true) || abort()\n    pinMode(pin, INPUT_PULLUP)\n    assert(digitalRead(pin) == 1, true) || abort()\n    pinMode(pin, INPUT_PULLDOWN)\n    assert(digitalRead(pin) == 0, true) || abort()\n    pinMode(pin, OUTPUT)\n    digitalWrite(pin, HIGH)\n    digitalWrite(pin, LOW)\n    pinMode(pin, OUTPUT_OPEN_DRAIN)\n    digitalWrite(pin, HIGH)\n    digitalWrite(pin, LOW)\n  })\n}\n\n// See clock  docs in the IDE. Not copied here.\nfunction clockSuite() {\n  assert(clockYear() >= 2021, true) || abort()\n  assert(clockYear() <= 2041, true) || abort() // Dear lord Pixel, bless this project such that by your mercy this test shall one day be executed and fail. Amen.\n  assert(clockYear(), floor(clockYear())) || abort()\n  \n  assert(clockMonth() >= 1, true) || abort()\n  assert(clockMonth() <= 12, true) || abort()\n  assert(clockMonth(), floor(clockMonth())) || abort()\n  \n  assert(clockDay() >= 1, true) || abort()\n  assert(clockDay() <= 31, true) || abort()\n  assert(clockDay(), floor(clockDay())) || abort()\n  \n  assert(clockHour() >= 0, true) || abort()\n  assert(clockHour() <= 23, true) || abort()\n  assert(clockHour(), floor(clockHour())) || abort()\n  \n  assert(clockMinute() >= 0, true) || abort()\n  assert(clockMinute() <= 59, true) || abort()\n  assert(clockMinute(), floor(clockMinute())) || abort()\n  \n  assert(clockSecond() >= 0, true) || abort()\n  assert(clockSecond() <= 59, true) || abort()\n  assert(clockSecond(), floor(clockSecond())) || abort()\n  \n  assert(clockWeekday() >= 1, true) || abort()\n  assert(clockWeekday() <= 7, true) || abort()\n  assert(clockWeekday(), floor(clockWeekday())) || abort()\n}\n\n\nexport function beforeRender(delta) {\n  // These are included just to have them called once - they're not actually asserted\n  t1 = time(.1)\n  \n  // v3.17+ only\n  resetTransform()\n  transform(.11, .21, .31, .41, .12, .22, .32, .42, .13, .23, .33, .43, .14, .24, .34, .44)\n  translate(-.5, -.5)\n  scale(2, .5)\n  rotateX(PI)\n  rotateY(PI2)\n  rotateZ(PI3_4)\n  rotate(-PI)\n  translate3D(-.5, 1, -.5)\n  scale3D(.01, .02, 3)\n}\n\nexport function render(index) {\n  // Just to have these called once\n  rgb(.1, .2, .3)\n  hsv24(.1, .2, .3)\n  \n  // Green/red for pass/fail\n  pass = results[index]\n  h = pass ? .33 : 0\n  v = pass == -1 ? 0 : .2\n  hsv(h, 1, v)\n}\n\nexport function render2D(index, x, y) { render(index) }\nexport function render3D(index, x, y, z) { render(index) }\n\n\n/********************************************************************************\n * Uncomment the test suites to run\n ********************************************************************************/\n\nscopeSuite()\ncontrolFlowSuite()\noperationsSuite()\nmathSuite()\narraySuite()\nwaveSuite()\nioSuite()\nclockSuite()\n\nexport var failCount, passCount\nfailCount = results.reduce((acc, v) => acc + (v==0), 0)\npassCount = results.reduce((acc, v) => acc + (v==1), 0)\n\n"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAj/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAYH/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AhQBBM0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf//Z"
}